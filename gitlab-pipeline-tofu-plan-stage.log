Running with gitlab-runner 17.10.0~pre.41.g5c23fd8e (5c23fd8e)
  on blue-5.saas-linux-small-amd64.runners-manager.gitlab.com/default -AzERasQ, system ID: s_4cb09cee29e2
Preparing the "docker+machine" executor
Using Docker executor with image public.ecr.aws/f5s3w0u8/opentofu:latest ...
Pulling docker image public.ecr.aws/f5s3w0u8/opentofu:latest ...
Using docker image sha256:920700fe846074b1d2aba9cb209759d4e355824b46e2431e8e0bbdcfcb63b3f7 for public.ecr.aws/f5s3w0u8/opentofu:latest with digest public.ecr.aws/f5s3w0u8/opentofu@sha256:0668d675d7d160bfae21ca776a9a652dacb42c8481739d1ac416506eb1b71179 ...
Preparing environment
Running on runner--azerasq-project-22333783-concurrent-0 via runner-azerasq-s-l-s-amd64-1743523709-09d1dfc4...
Getting source from Git repository
Fetching changes with git depth set to 50...
Initialized empty Git repository in /builds/tech-assessment/infra/.git/
Created fresh repository.
Checking out 09e10130 as detached HEAD (ref is feature/eks-infra-example)...
Skipping Git submodules setup
$ git remote set-url origin "${CI_REPOSITORY_URL}" || echo 'Not a git repository; skipping'
Executing "step_script" stage of the job script
Using docker image sha256:920700fe846074b1d2aba9cb209759d4e355824b46e2431e8e0bbdcfcb63b3f7 for public.ecr.aws/f5s3w0u8/opentofu:latest with digest public.ecr.aws/f5s3w0u8/opentofu@sha256:0668d675d7d160bfae21ca776a9a652dacb42c8481739d1ac416506eb1b71179 ...
$ rm -rf .terraform
$ tofu --version
OpenTofu v1.9.0
on linux_amd64
$ echo "Configuring Terraform Backend"
Configuring Terraform Backend
$ export TF_HTTP_ADDRESS="https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/${ENV_LC}"
$ export TF_HTTP_LOCK_ADDRESS="https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/${ENV_LC}/lock"
$ export TF_HTTP_UNLOCK_ADDRESS="https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/${ENV_LC}/lock"
$ export TF_HTTP_LOCK_METHOD="POST"
$ export TF_HTTP_UNLOCK_METHOD="DELETE"
$ export TF_HTTP_USERNAME="$MY_CI_JOB_KEY"
$ export TF_HTTP_PASSWORD="$MY_CI_JOB_TOKEN"
$ tofu init
Initializing the backend...
Successfully configured the backend "http"! OpenTofu will automatically
use this backend unless the backend configuration changes.
Initializing modules...
Downloading registry.opentofu.org/terraform-aws-modules/eks/aws 20.35.0 for eks...
- eks in .terraform/modules/eks
- eks.eks_managed_node_group in .terraform/modules/eks/modules/eks-managed-node-group
- eks.eks_managed_node_group.user_data in .terraform/modules/eks/modules/_user_data
- eks.fargate_profile in .terraform/modules/eks/modules/fargate-profile
Downloading registry.opentofu.org/terraform-aws-modules/kms/aws 2.1.0 for eks.kms...
- eks.kms in .terraform/modules/eks.kms
- eks.self_managed_node_group in .terraform/modules/eks/modules/self-managed-node-group
- eks.self_managed_node_group.user_data in .terraform/modules/eks/modules/_user_data
Initializing provider plugins...
- Finding hashicorp/helm versions matching ">= 2.7.0"...
- Finding hashicorp/null versions matching ">= 3.0.0"...
- Finding hashicorp/tls versions matching ">= 3.0.0"...
- Finding gavinbunney/kubectl versions matching ">= 1.7.0"...
- Finding hashicorp/cloudinit versions matching ">= 2.0.0"...
- Finding hashicorp/local versions matching "~> 2.1"...
- Finding hashicorp/time versions matching ">= 0.9.0"...
- Finding hashicorp/kubernetes versions matching "2.7.0"...
- Finding hashicorp/aws versions matching "> 4.29.0, >= 4.33.0, >= 5.83.0"...
- Installing hashicorp/aws v5.93.0...
- Installed hashicorp/aws v5.93.0 (signed, key ID 0C0AF313E5FD9F80)
- Installing hashicorp/null v3.2.3...
- Installed hashicorp/null v3.2.3 (signed, key ID 0C0AF313E5FD9F80)
- Installing hashicorp/tls v4.0.6...
- Installed hashicorp/tls v4.0.6 (signed, key ID 0C0AF313E5FD9F80)
- Installing hashicorp/time v0.13.0...
- Installed hashicorp/time v0.13.0 (signed, key ID 0C0AF313E5FD9F80)
- Installing hashicorp/local v2.5.2...
- Installed hashicorp/local v2.5.2 (signed, key ID 0C0AF313E5FD9F80)
- Installing hashicorp/kubernetes v2.7.0...
- Installed hashicorp/kubernetes v2.7.0 (signed, key ID 0C0AF313E5FD9F80)
- Installing hashicorp/helm v2.17.0...
- Installed hashicorp/helm v2.17.0 (signed, key ID 0C0AF313E5FD9F80)
- Installing gavinbunney/kubectl v1.19.0...
- Installed gavinbunney/kubectl v1.19.0 (signed, key ID 1E1CE42504F5FBB2)
- Installing hashicorp/cloudinit v2.3.6...
- Installed hashicorp/cloudinit v2.3.6 (signed, key ID 0C0AF313E5FD9F80)
Providers are signed by their developers.
If you'd like to know more about provider signing, you can read about it here:
https://opentofu.org/docs/cli/plugins/signing/
OpenTofu has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that OpenTofu can guarantee to make the same selections by default when
you run "tofu init" in the future.
OpenTofu has been successfully initialized!
You may now begin working with OpenTofu. Try running "tofu plan" to see
any changes that are required for your infrastructure. All OpenTofu commands
should now work.
If you ever set or change modules or backend configuration for OpenTofu,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
$ tofu plan -out "planfile"
module.eks.module.kms.data.aws_partition.current[0]: Reading...
module.eks.data.aws_iam_policy_document.assume_role_policy[0]: Reading...
module.eks.data.aws_partition.current[0]: Reading...
module.eks.data.aws_caller_identity.current[0]: Reading...
module.eks.module.kms.data.aws_caller_identity.current[0]: Reading...
data.aws_availability_zones.get_all: Reading...
module.eks.data.aws_iam_policy_document.assume_role_policy[0]: Read complete after 0s [id=2830595799]
module.eks.module.kms.data.aws_partition.current[0]: Read complete after 0s [id=aws]
module.eks.data.aws_partition.current[0]: Read complete after 0s [id=aws]
module.eks.data.aws_iam_policy_document.custom[0]: Reading...
module.eks.data.aws_iam_policy_document.custom[0]: Read complete after 0s [id=513122117]
module.eks.data.aws_caller_identity.current[0]: Read complete after 0s [id=123456789012]
module.eks.data.aws_iam_session_context.current[0]: Reading...
module.eks.data.aws_iam_session_context.current[0]: Read complete after 0s [id=arn:aws:iam::123456789012:user/terraform]
module.eks.module.eks_managed_node_group["worker-group-2"].data.aws_caller_identity.current: Reading...
module.eks.module.kms.data.aws_caller_identity.current[0]: Read complete after 0s [id=123456789012]
module.eks.module.eks_managed_node_group["worker-group-1"].data.aws_caller_identity.current: Reading...
module.eks.module.eks_managed_node_group["worker-group-1"].data.aws_partition.current: Reading...
module.eks.module.eks_managed_node_group["worker-group-2"].data.aws_caller_identity.current: Read complete after 0s [id=123456789012]
module.eks.module.eks_managed_node_group["worker-group-2"].data.aws_partition.current: Reading...
module.eks.module.eks_managed_node_group["worker-group-2"].data.aws_partition.current: Read complete after 0s [id=aws]
module.eks.module.eks_managed_node_group["worker-group-1"].data.aws_partition.current: Read complete after 0s [id=aws]
module.eks.module.eks_managed_node_group["worker-group-1"].data.aws_caller_identity.current: Read complete after 0s [id=123456789012]
module.eks.module.eks_managed_node_group["worker-group-1"].data.aws_iam_policy_document.assume_role_policy[0]: Reading...
module.eks.module.eks_managed_node_group["worker-group-2"].data.aws_iam_policy_document.assume_role_policy[0]: Reading...
module.eks.module.eks_managed_node_group["worker-group-1"].data.aws_iam_policy_document.assume_role_policy[0]: Read complete after 0s [id=2560088296]
module.eks.module.eks_managed_node_group["worker-group-2"].data.aws_iam_policy_document.assume_role_policy[0]: Read complete after 0s [id=2560088296]
data.aws_availability_zones.get_all: Read complete after 0s [id=us-east-2]
OpenTofu used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  + create
 <= read (data resources)
OpenTofu will perform the following actions:
  # data.aws_eks_cluster.cluster will be read during apply
  # (depends on a resource or a module with changes pending)
 <= data "aws_eks_cluster" "cluster" {
      + access_config             = (known after apply)
      + arn                       = (known after apply)
      + certificate_authority     = (known after apply)
      + cluster_id                = (known after apply)
      + compute_config            = (known after apply)
      + created_at                = (known after apply)
      + enabled_cluster_log_types = (known after apply)
      + endpoint                  = (known after apply)
      + id                        = (known after apply)
      + identity                  = (known after apply)
      + kubernetes_network_config = (known after apply)
      + name                      = "example"
      + outpost_config            = (known after apply)
      + platform_version          = (known after apply)
      + remote_network_config     = (known after apply)
      + role_arn                  = (known after apply)
      + status                    = (known after apply)
      + storage_config            = (known after apply)
      + tags                      = (known after apply)
      + upgrade_policy            = (known after apply)
      + version                   = (known after apply)
      + vpc_config                = (known after apply)
      + zonal_shift_config        = (known after apply)
    }
  # data.aws_eks_cluster_auth.cluster will be read during apply
  # (depends on a resource or a module with changes pending)
 <= data "aws_eks_cluster_auth" "cluster" {
      + id    = (known after apply)
      + name  = "example"
      + token = (sensitive value)
    }
  # aws_eip.eip[0] will be created
  + resource "aws_eip" "eip" {
      + allocation_id        = (known after apply)
      + arn                  = (known after apply)
      + association_id       = (known after apply)
      + carrier_ip           = (known after apply)
      + customer_owned_ip    = (known after apply)
      + domain               = (known after apply)
      + id                   = (known after apply)
      + instance             = (known after apply)
      + ipam_pool_id         = (known after apply)
      + network_border_group = (known after apply)
      + network_interface    = (known after apply)
      + private_dns          = (known after apply)
      + private_ip           = (known after apply)
      + ptr_record           = (known after apply)
      + public_dns           = (known after apply)
      + public_ip            = (known after apply)
      + public_ipv4_pool     = (known after apply)
      + tags                 = {
          + "Name"       = "example.us-east-2a"
          + "built-with" = "terraform"
          + "region"     = "us-east-2a"
          + "vpc"        = "example"
        }
      + tags_all             = {
          + "Name"       = "example.us-east-2a"
          + "built-with" = "terraform"
          + "region"     = "us-east-2a"
          + "vpc"        = "example"
        }
      + vpc                  = (known after apply)
    }
  # aws_eip.eip[1] will be created
  + resource "aws_eip" "eip" {
      + allocation_id        = (known after apply)
      + arn                  = (known after apply)
      + association_id       = (known after apply)
      + carrier_ip           = (known after apply)
      + customer_owned_ip    = (known after apply)
      + domain               = (known after apply)
      + id                   = (known after apply)
      + instance             = (known after apply)
      + ipam_pool_id         = (known after apply)
      + network_border_group = (known after apply)
      + network_interface    = (known after apply)
      + private_dns          = (known after apply)
      + private_ip           = (known after apply)
      + ptr_record           = (known after apply)
      + public_dns           = (known after apply)
      + public_ip            = (known after apply)
      + public_ipv4_pool     = (known after apply)
      + tags                 = {
          + "Name"       = "example.us-east-2b"
          + "built-with" = "terraform"
          + "region"     = "us-east-2b"
          + "vpc"        = "example"
        }
      + tags_all             = {
          + "Name"       = "example.us-east-2b"
          + "built-with" = "terraform"
          + "region"     = "us-east-2b"
          + "vpc"        = "example"
        }
      + vpc                  = (known after apply)
    }
  # aws_eip.eip[2] will be created
  + resource "aws_eip" "eip" {
      + allocation_id        = (known after apply)
      + arn                  = (known after apply)
      + association_id       = (known after apply)
      + carrier_ip           = (known after apply)
      + customer_owned_ip    = (known after apply)
      + domain               = (known after apply)
      + id                   = (known after apply)
      + instance             = (known after apply)
      + ipam_pool_id         = (known after apply)
      + network_border_group = (known after apply)
      + network_interface    = (known after apply)
      + private_dns          = (known after apply)
      + private_ip           = (known after apply)
      + ptr_record           = (known after apply)
      + public_dns           = (known after apply)
      + public_ip            = (known after apply)
      + public_ipv4_pool     = (known after apply)
      + tags                 = {
          + "Name"       = "example.us-east-2c"
          + "built-with" = "terraform"
          + "region"     = "us-east-2c"
          + "vpc"        = "example"
        }
      + tags_all             = {
          + "Name"       = "example.us-east-2c"
          + "built-with" = "terraform"
          + "region"     = "us-east-2c"
          + "vpc"        = "example"
        }
      + vpc                  = (known after apply)
    }
  # aws_internet_gateway.main will be created
  + resource "aws_internet_gateway" "main" {
      + arn      = (known after apply)
      + id       = (known after apply)
      + owner_id = (known after apply)
      + tags     = {
          + "Name"       = "example"
          + "built-with" = "terraform"
        }
      + tags_all = {
          + "Name"       = "example"
          + "built-with" = "terraform"
        }
      + vpc_id   = (known after apply)
    }
  # aws_nat_gateway.ngw[0] will be created
  + resource "aws_nat_gateway" "ngw" {
      + allocation_id                      = (known after apply)
      + association_id                     = (known after apply)
      + connectivity_type                  = "public"
      + id                                 = (known after apply)
      + network_interface_id               = (known after apply)
      + private_ip                         = (known after apply)
      + public_ip                          = (known after apply)
      + secondary_private_ip_address_count = (known after apply)
      + secondary_private_ip_addresses     = (known after apply)
      + subnet_id                          = (known after apply)
      + tags                               = {
          + "Name"       = "example.us-east-2a"
          + "built-with" = "terraform"
          + "region"     = "us-east-2a"
          + "vpc"        = "example"
        }
      + tags_all                           = {
          + "Name"       = "example.us-east-2a"
          + "built-with" = "terraform"
          + "region"     = "us-east-2a"
          + "vpc"        = "example"
        }
    }
  # aws_nat_gateway.ngw[1] will be created
  + resource "aws_nat_gateway" "ngw" {
      + allocation_id                      = (known after apply)
      + association_id                     = (known after apply)
      + connectivity_type                  = "public"
      + id                                 = (known after apply)
      + network_interface_id               = (known after apply)
      + private_ip                         = (known after apply)
      + public_ip                          = (known after apply)
      + secondary_private_ip_address_count = (known after apply)
      + secondary_private_ip_addresses     = (known after apply)
      + subnet_id                          = (known after apply)
      + tags                               = {
          + "Name"       = "example.us-east-2b"
          + "built-with" = "terraform"
          + "region"     = "us-east-2b"
          + "vpc"        = "example"
        }
      + tags_all                           = {
          + "Name"       = "example.us-east-2b"
          + "built-with" = "terraform"
          + "region"     = "us-east-2b"
          + "vpc"        = "example"
        }
    }
  # aws_nat_gateway.ngw[2] will be created
  + resource "aws_nat_gateway" "ngw" {
      + allocation_id                      = (known after apply)
      + association_id                     = (known after apply)
      + connectivity_type                  = "public"
      + id                                 = (known after apply)
      + network_interface_id               = (known after apply)
      + private_ip                         = (known after apply)
      + public_ip                          = (known after apply)
      + secondary_private_ip_address_count = (known after apply)
      + secondary_private_ip_addresses     = (known after apply)
      + subnet_id                          = (known after apply)
      + tags                               = {
          + "Name"       = "example.us-east-2c"
          + "built-with" = "terraform"
          + "region"     = "us-east-2c"
          + "vpc"        = "example"
        }
      + tags_all                           = {
          + "Name"       = "example.us-east-2c"
          + "built-with" = "terraform"
          + "region"     = "us-east-2c"
          + "vpc"        = "example"
        }
    }
  # aws_route.private[0] will be created
  + resource "aws_route" "private" {
      + destination_cidr_block = "0.0.0.0/0"
      + id                     = (known after apply)
      + instance_id            = (known after apply)
      + instance_owner_id      = (known after apply)
      + nat_gateway_id         = (known after apply)
      + network_interface_id   = (known after apply)
      + origin                 = (known after apply)
      + route_table_id         = (known after apply)
      + state                  = (known after apply)
    }
  # aws_route.private[1] will be created
  + resource "aws_route" "private" {
      + destination_cidr_block = "0.0.0.0/0"
      + id                     = (known after apply)
      + instance_id            = (known after apply)
      + instance_owner_id      = (known after apply)
      + nat_gateway_id         = (known after apply)
      + network_interface_id   = (known after apply)
      + origin                 = (known after apply)
      + route_table_id         = (known after apply)
      + state                  = (known after apply)
    }
  # aws_route.private[2] will be created
  + resource "aws_route" "private" {
      + destination_cidr_block = "0.0.0.0/0"
      + id                     = (known after apply)
      + instance_id            = (known after apply)
      + instance_owner_id      = (known after apply)
      + nat_gateway_id         = (known after apply)
      + network_interface_id   = (known after apply)
      + origin                 = (known after apply)
      + route_table_id         = (known after apply)
      + state                  = (known after apply)
    }
  # aws_route.public will be created
  + resource "aws_route" "public" {
      + destination_cidr_block = "0.0.0.0/0"
      + gateway_id             = (known after apply)
      + id                     = (known after apply)
      + instance_id            = (known after apply)
      + instance_owner_id      = (known after apply)
      + network_interface_id   = (known after apply)
      + origin                 = (known after apply)
      + route_table_id         = (known after apply)
      + state                  = (known after apply)
    }
  # aws_route_table.private[0] will be created
  + resource "aws_route_table" "private" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = (known after apply)
      + tags             = {
          + "Name"       = "private"
          + "built-with" = "terraform"
          + "region"     = "us-east-2a"
          + "vpc"        = "example"
        }
      + tags_all         = {
          + "Name"       = "private"
          + "built-with" = "terraform"
          + "region"     = "us-east-2a"
          + "vpc"        = "example"
        }
      + vpc_id           = (known after apply)
    }
  # aws_route_table.private[1] will be created
  + resource "aws_route_table" "private" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = (known after apply)
      + tags             = {
          + "Name"       = "private"
          + "built-with" = "terraform"
          + "region"     = "us-east-2b"
          + "vpc"        = "example"
        }
      + tags_all         = {
          + "Name"       = "private"
          + "built-with" = "terraform"
          + "region"     = "us-east-2b"
          + "vpc"        = "example"
        }
      + vpc_id           = (known after apply)
    }
  # aws_route_table.private[2] will be created
  + resource "aws_route_table" "private" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = (known after apply)
      + tags             = {
          + "Name"       = "private"
          + "built-with" = "terraform"
          + "region"     = "us-east-2c"
          + "vpc"        = "example"
        }
      + tags_all         = {
          + "Name"       = "private"
          + "built-with" = "terraform"
          + "region"     = "us-east-2c"
          + "vpc"        = "example"
        }
      + vpc_id           = (known after apply)
    }
  # aws_route_table.public will be created
  + resource "aws_route_table" "public" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = (known after apply)
      + tags             = {
          + "Name"       = "public"
          + "VPC"        = "example"
          + "built-with" = "terraform"
          + "region"     = "all"
        }
      + tags_all         = {
          + "Name"       = "public"
          + "VPC"        = "example"
          + "built-with" = "terraform"
          + "region"     = "all"
        }
      + vpc_id           = (known after apply)
    }
  # aws_route_table_association.private[0] will be created
  + resource "aws_route_table_association" "private" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }
  # aws_route_table_association.private[1] will be created
  + resource "aws_route_table_association" "private" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }
  # aws_route_table_association.private[2] will be created
  + resource "aws_route_table_association" "private" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }
  # aws_route_table_association.public[0] will be created
  + resource "aws_route_table_association" "public" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }
  # aws_route_table_association.public[1] will be created
  + resource "aws_route_table_association" "public" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }
  # aws_route_table_association.public[2] will be created
  + resource "aws_route_table_association" "public" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }
  # aws_security_group.all_worker_mgmt will be created
  + resource "aws_security_group" "all_worker_mgmt" {
      + arn                    = (known after apply)
      + description            = "Managed by Terraform"
      + egress                 = (known after apply)
      + id                     = (known after apply)
      + ingress                = [
          + {
              + cidr_blocks      = [
                  + "10.0.0.0/8",
                  + "172.16.0.0/12",
                  + "192.168.0.0/16",
                ]
              + description      = ""
              + from_port        = 22
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "tcp"
              + security_groups  = []
              + self             = false
              + to_port          = 22
            },
        ]
      + name                   = (known after apply)
      + name_prefix            = "all_worker_management"
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags_all               = (known after apply)
      + vpc_id                 = (known after apply)
    }
  # aws_security_group.worker_group_mgmt_one will be created
  + resource "aws_security_group" "worker_group_mgmt_one" {
      + arn                    = (known after apply)
      + description            = "Managed by Terraform"
      + egress                 = (known after apply)
      + id                     = (known after apply)
      + ingress                = [
          + {
              + cidr_blocks      = [
                  + "10.0.0.0/8",
                ]
              + description      = ""
              + from_port        = 22
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "tcp"
              + security_groups  = []
              + self             = false
              + to_port          = 22
            },
        ]
      + name                   = (known after apply)
      + name_prefix            = "worker_group_mgmt_one"
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags_all               = (known after apply)
      + vpc_id                 = (known after apply)
    }
  # aws_security_group.worker_group_mgmt_two will be created
  + resource "aws_security_group" "worker_group_mgmt_two" {
      + arn                    = (known after apply)
      + description            = "Managed by Terraform"
      + egress                 = (known after apply)
      + id                     = (known after apply)
      + ingress                = [
          + {
              + cidr_blocks      = [
                  + "192.168.0.0/16",
                ]
              + description      = ""
              + from_port        = 22
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "tcp"
              + security_groups  = []
              + self             = false
              + to_port          = 22
            },
        ]
      + name                   = (known after apply)
      + name_prefix            = "worker_group_mgmt_two"
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags_all               = (known after apply)
      + vpc_id                 = (known after apply)
    }
  # aws_subnet.private[0] will be created
  + resource "aws_subnet" "private" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "us-east-2a"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.100.2.0/25"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"       = "private-0.example"
          + "built-with" = "terraform"
        }
      + tags_all                                       = {
          + "Name"       = "private-0.example"
          + "built-with" = "terraform"
        }
      + vpc_id                                         = (known after apply)
    }
  # aws_subnet.private[1] will be created
  + resource "aws_subnet" "private" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "us-east-2b"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.100.2.128/25"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"       = "private-1.example"
          + "built-with" = "terraform"
        }
      + tags_all                                       = {
          + "Name"       = "private-1.example"
          + "built-with" = "terraform"
        }
      + vpc_id                                         = (known after apply)
    }
  # aws_subnet.private[2] will be created
  + resource "aws_subnet" "private" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "us-east-2c"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.100.3.0/25"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"       = "private-2.example"
          + "built-with" = "terraform"
        }
      + tags_all                                       = {
          + "Name"       = "private-2.example"
          + "built-with" = "terraform"
        }
      + vpc_id                                         = (known after apply)
    }
  # aws_subnet.public[0] will be created
  + resource "aws_subnet" "public" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "us-east-2a"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.100.0.0/25"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"       = "public-0.example"
          + "built-with" = "terraform"
        }
      + tags_all                                       = {
          + "Name"       = "public-0.example"
          + "built-with" = "terraform"
        }
      + vpc_id                                         = (known after apply)
    }
  # aws_subnet.public[1] will be created
  + resource "aws_subnet" "public" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "us-east-2b"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.100.0.128/25"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"       = "public-1.example"
          + "built-with" = "terraform"
        }
      + tags_all                                       = {
          + "Name"       = "public-1.example"
          + "built-with" = "terraform"
        }
      + vpc_id                                         = (known after apply)
    }
  # aws_subnet.public[2] will be created
  + resource "aws_subnet" "public" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "us-east-2c"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.100.1.0/25"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name"       = "public-2.example"
          + "built-with" = "terraform"
        }
      + tags_all                                       = {
          + "Name"       = "public-2.example"
          + "built-with" = "terraform"
        }
      + vpc_id                                         = (known after apply)
    }
  # aws_vpc.main will be created
  + resource "aws_vpc" "main" {
      + arn                                  = (known after apply)
      + cidr_block                           = "10.100.0.0/22"
      + default_network_acl_id               = (known after apply)
      + default_route_table_id               = (known after apply)
      + default_security_group_id            = (known after apply)
      + dhcp_options_id                      = (known after apply)
      + enable_dns_hostnames                 = true
      + enable_dns_support                   = true
      + enable_network_address_usage_metrics = (known after apply)
      + id                                   = (known after apply)
      + instance_tenancy                     = "default"
      + ipv6_association_id                  = (known after apply)
      + ipv6_cidr_block                      = (known after apply)
      + ipv6_cidr_block_network_border_group = (known after apply)
      + main_route_table_id                  = (known after apply)
      + owner_id                             = (known after apply)
      + tags                                 = {
          + "Name"       = "example"
          + "built-with" = "terraform"
          + "vpc"        = "example"
        }
      + tags_all                             = {
          + "Name"       = "example"
          + "built-with" = "terraform"
          + "vpc"        = "example"
        }
    }
  # kubectl_manifest.jenkins_ns will be created
  + resource "kubectl_manifest" "jenkins_ns" {
      + api_version             = "v1"
      + apply_only              = false
      + force_conflicts         = false
      + force_new               = false
      + id                      = (known after apply)
      + kind                    = "Namespace"
      + live_manifest_incluster = (sensitive value)
      + live_uid                = (known after apply)
      + name                    = "jenkins"
      + namespace               = (known after apply)
      + server_side_apply       = false
      + uid                     = (known after apply)
      + validate_schema         = true
      + wait_for_rollout        = true
      + yaml_body               = (sensitive value)
      + yaml_body_parsed        = <<-EOT
            apiVersion: v1
            kind: Namespace
            metadata:
              name: jenkins
        EOT
      + yaml_incluster          = (sensitive value)
    }
  # null_resource.generated_private_subnets[0] will be created
  + resource "null_resource" "generated_private_subnets" {
      + id       = (known after apply)
      + triggers = {
          + "cidr_block" = "10.100.0.12/30"
        }
    }
  # null_resource.generated_private_subnets[1] will be created
  + resource "null_resource" "generated_private_subnets" {
      + id       = (known after apply)
      + triggers = {
          + "cidr_block" = "10.100.0.16/30"
        }
    }
  # null_resource.generated_private_subnets[2] will be created
  + resource "null_resource" "generated_private_subnets" {
      + id       = (known after apply)
      + triggers = {
          + "cidr_block" = "10.100.0.20/30"
        }
    }
  # null_resource.generated_public_subnets[0] will be created
  + resource "null_resource" "generated_public_subnets" {
      + id       = (known after apply)
      + triggers = {
          + "cidr_block" = "10.100.0.0/30"
        }
    }
  # null_resource.generated_public_subnets[1] will be created
  + resource "null_resource" "generated_public_subnets" {
      + id       = (known after apply)
      + triggers = {
          + "cidr_block" = "10.100.0.4/30"
        }
    }
  # null_resource.generated_public_subnets[2] will be created
  + resource "null_resource" "generated_public_subnets" {
      + id       = (known after apply)
      + triggers = {
          + "cidr_block" = "10.100.0.8/30"
        }
    }
  # module.eks.data.aws_eks_addon_version.this["coredns"] will be read during apply
  # (depends on a resource or a module with changes pending)
 <= data "aws_eks_addon_version" "this" {
      + addon_name         = "coredns"
      + id                 = (known after apply)
      + kubernetes_version = "1.30"
      + version            = (known after apply)
    }
  # module.eks.data.aws_eks_addon_version.this["eks-pod-identity-agent"] will be read during apply
  # (depends on a resource or a module with changes pending)
 <= data "aws_eks_addon_version" "this" {
      + addon_name         = "eks-pod-identity-agent"
      + id                 = (known after apply)
      + kubernetes_version = "1.30"
      + version            = (known after apply)
    }
  # module.eks.data.aws_eks_addon_version.this["kube-proxy"] will be read during apply
  # (depends on a resource or a module with changes pending)
 <= data "aws_eks_addon_version" "this" {
      + addon_name         = "kube-proxy"
      + id                 = (known after apply)
      + kubernetes_version = "1.30"
      + version            = (known after apply)
    }
  # module.eks.data.aws_eks_addon_version.this["vpc-cni"] will be read during apply
  # (depends on a resource or a module with changes pending)
 <= data "aws_eks_addon_version" "this" {
      + addon_name         = "vpc-cni"
      + id                 = (known after apply)
      + kubernetes_version = "1.30"
      + version            = (known after apply)
    }
  # module.eks.data.tls_certificate.this[0] will be read during apply
  # (config refers to values not yet known)
 <= data "tls_certificate" "this" {
      + certificates = (known after apply)
      + id           = (known after apply)
      + url          = (known after apply)
    }
  # module.eks.aws_cloudwatch_log_group.this[0] will be created
  + resource "aws_cloudwatch_log_group" "this" {
      + arn               = (known after apply)
      + id                = (known after apply)
      + log_group_class   = (known after apply)
      + name              = "/aws/eks/example/cluster"
      + name_prefix       = (known after apply)
      + retention_in_days = 90
      + skip_destroy      = false
      + tags              = {
          + "Environment" = "example"
          + "Name"        = "/aws/eks/example/cluster"
        }
      + tags_all          = {
          + "Environment" = "example"
          + "Name"        = "/aws/eks/example/cluster"
        }
    }
  # module.eks.aws_ec2_tag.cluster_primary_security_group["Environment"] will be created
  + resource "aws_ec2_tag" "cluster_primary_security_group" {
      + id          = (known after apply)
      + key         = "Environment"
      + resource_id = (known after apply)
      + value       = "example"
    }
  # module.eks.aws_eks_access_entry.this["cluster_creator"] will be created
  + resource "aws_eks_access_entry" "this" {
      + access_entry_arn  = (known after apply)
      + cluster_name      = (known after apply)
      + created_at        = (known after apply)
      + id                = (known after apply)
      + kubernetes_groups = (known after apply)
      + modified_at       = (known after apply)
      + principal_arn     = "arn:aws:iam::123456789012:user/terraform"
      + tags              = {
          + "Environment" = "example"
        }
      + tags_all          = {
          + "Environment" = "example"
        }
      + type              = "STANDARD"
      + user_name         = (known after apply)
    }
  # module.eks.aws_eks_access_policy_association.this["cluster_creator_admin"] will be created
  + resource "aws_eks_access_policy_association" "this" {
      + associated_at = (known after apply)
      + cluster_name  = (known after apply)
      + id            = (known after apply)
      + modified_at   = (known after apply)
      + policy_arn    = "arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy"
      + principal_arn = "arn:aws:iam::123456789012:user/terraform"
      + access_scope {
          + type = "cluster"
        }
    }
  # module.eks.aws_eks_addon.this["coredns"] will be created
  + resource "aws_eks_addon" "this" {
      + addon_name                  = "coredns"
      + addon_version               = (known after apply)
      + arn                         = (known after apply)
      + cluster_name                = (known after apply)
      + configuration_values        = (known after apply)
      + created_at                  = (known after apply)
      + id                          = (known after apply)
      + modified_at                 = (known after apply)
      + preserve                    = true
      + resolve_conflicts_on_create = "OVERWRITE"
      + resolve_conflicts_on_update = "OVERWRITE"
      + tags                        = {
          + "Environment" = "example"
        }
      + tags_all                    = {
          + "Environment" = "example"
        }
      + timeouts {}
    }
  # module.eks.aws_eks_addon.this["eks-pod-identity-agent"] will be created
  + resource "aws_eks_addon" "this" {
      + addon_name                  = "eks-pod-identity-agent"
      + addon_version               = (known after apply)
      + arn                         = (known after apply)
      + cluster_name                = (known after apply)
      + configuration_values        = (known after apply)
      + created_at                  = (known after apply)
      + id                          = (known after apply)
      + modified_at                 = (known after apply)
      + preserve                    = true
      + resolve_conflicts_on_create = "OVERWRITE"
      + resolve_conflicts_on_update = "OVERWRITE"
      + tags                        = {
          + "Environment" = "example"
        }
      + tags_all                    = {
          + "Environment" = "example"
        }
      + timeouts {}
    }
  # module.eks.aws_eks_addon.this["kube-proxy"] will be created
  + resource "aws_eks_addon" "this" {
      + addon_name                  = "kube-proxy"
      + addon_version               = (known after apply)
      + arn                         = (known after apply)
      + cluster_name                = (known after apply)
      + configuration_values        = (known after apply)
      + created_at                  = (known after apply)
      + id                          = (known after apply)
      + modified_at                 = (known after apply)
      + preserve                    = true
      + resolve_conflicts_on_create = "OVERWRITE"
      + resolve_conflicts_on_update = "OVERWRITE"
      + tags                        = {
          + "Environment" = "example"
        }
      + tags_all                    = {
          + "Environment" = "example"
        }
      + timeouts {}
    }
  # module.eks.aws_eks_addon.this["vpc-cni"] will be created
  + resource "aws_eks_addon" "this" {
      + addon_name                  = "vpc-cni"
      + addon_version               = (known after apply)
      + arn                         = (known after apply)
      + cluster_name                = (known after apply)
      + configuration_values        = (known after apply)
      + created_at                  = (known after apply)
      + id                          = (known after apply)
      + modified_at                 = (known after apply)
      + preserve                    = true
      + resolve_conflicts_on_create = "OVERWRITE"
      + resolve_conflicts_on_update = "OVERWRITE"
      + tags                        = {
          + "Environment" = "example"
        }
      + tags_all                    = {
          + "Environment" = "example"
        }
      + timeouts {}
    }
  # module.eks.aws_eks_cluster.this[0] will be created
  + resource "aws_eks_cluster" "this" {
      + arn                           = (known after apply)
      + bootstrap_self_managed_addons = true
      + certificate_authority         = (known after apply)
      + cluster_id                    = (known after apply)
      + created_at                    = (known after apply)
      + enabled_cluster_log_types     = [
          + "api",
          + "audit",
          + "authenticator",
        ]
      + endpoint                      = (known after apply)
      + id                            = (known after apply)
      + identity                      = (known after apply)
      + name                          = "example"
      + platform_version              = (known after apply)
      + role_arn                      = (known after apply)
      + status                        = (known after apply)
      + tags                          = {
          + "Environment"           = "example"
          + "terraform-aws-modules" = "eks"
        }
      + tags_all                      = {
          + "Environment"           = "example"
          + "terraform-aws-modules" = "eks"
        }
      + version                       = "1.30"
      + access_config {
          + authentication_mode                         = "API_AND_CONFIG_MAP"
          + bootstrap_cluster_creator_admin_permissions = false
        }
      + encryption_config {
          + resources = [
              + "secrets",
            ]
          + provider {
              + key_arn = (known after apply)
            }
        }
      + kubernetes_network_config {
          + ip_family         = "ipv4"
          + service_ipv4_cidr = (known after apply)
          + service_ipv6_cidr = (known after apply)
          + elastic_load_balancing (known after apply)
        }
      + timeouts {}
      + upgrade_policy (known after apply)
      + vpc_config {
          + cluster_security_group_id = (known after apply)
          + endpoint_private_access   = false
          + endpoint_public_access    = true
          + public_access_cidrs       = [
              + "0.0.0.0/0",
            ]
          + security_group_ids        = (known after apply)
          + subnet_ids                = (known after apply)
          + vpc_id                    = (known after apply)
        }
    }
  # module.eks.aws_iam_openid_connect_provider.oidc_provider[0] will be created
  + resource "aws_iam_openid_connect_provider" "oidc_provider" {
      + arn             = (known after apply)
      + client_id_list  = [
          + "sts.amazonaws.com",
        ]
      + id              = (known after apply)
      + tags            = {
          + "Environment" = "example"
          + "Name"        = "example-eks-irsa"
        }
      + tags_all        = {
          + "Environment" = "example"
          + "Name"        = "example-eks-irsa"
        }
      + thumbprint_list = (known after apply)
      + url             = (known after apply)
    }
  # module.eks.aws_iam_policy.cluster_encryption[0] will be created
  + resource "aws_iam_policy" "cluster_encryption" {
      + arn              = (known after apply)
      + attachment_count = (known after apply)
      + description      = "Cluster encryption policy to allow cluster role to utilize CMK provided"
      + id               = (known after apply)
      + name             = (known after apply)
      + name_prefix      = "example-cluster-ClusterEncryption"
      + path             = "/"
      + policy           = (known after apply)
      + policy_id        = (known after apply)
      + tags             = {
          + "Environment" = "example"
        }
      + tags_all         = {
          + "Environment" = "example"
        }
    }
  # module.eks.aws_iam_policy.custom[0] will be created
  + resource "aws_iam_policy" "custom" {
      + arn              = (known after apply)
      + attachment_count = (known after apply)
      + id               = (known after apply)
      + name             = (known after apply)
      + name_prefix      = "example-cluster-"
      + path             = "/"
      + policy           = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = [
                          + "ec2:RunInstances",
                          + "ec2:CreateLaunchTemplate",
                          + "ec2:CreateFleet",
                        ]
                      + Condition = {
                          + StringEquals = {
                              + "aws:RequestTag/eks:eks-cluster-name" = "${aws:PrincipalTag/eks:eks-cluster-name}"
                            }
                          + StringLike   = {
                              + "aws:RequestTag/eks:kubernetes-node-class-name" = "*"
                              + "aws:RequestTag/eks:kubernetes-node-pool-name"  = "*"
                            }
                        }
                      + Effect    = "Allow"
                      + Resource  = "*"
                      + Sid       = "Compute"
                    },
                  + {
                      + Action    = [
                          + "ec2:CreateVolume",
                          + "ec2:CreateSnapshot",
                        ]
                      + Condition = {
                          + StringEquals = {
                              + "aws:RequestTag/eks:eks-cluster-name" = "${aws:PrincipalTag/eks:eks-cluster-name}"
                            }
                        }
                      + Effect    = "Allow"
                      + Resource  = [
                          + "arn:aws:ec2:*:*:volume/*",
                          + "arn:aws:ec2:*:*:snapshot/*",
                        ]
                      + Sid       = "Storage"
                    },
                  + {
                      + Action    = "ec2:CreateNetworkInterface"
                      + Condition = {
                          + StringEquals = {
                              + "aws:RequestTag/eks:eks-cluster-name"         = "${aws:PrincipalTag/eks:eks-cluster-name}"
                              + "aws:RequestTag/eks:kubernetes-cni-node-name" = "*"
                            }
                        }
                      + Effect    = "Allow"
                      + Resource  = "*"
                      + Sid       = "Networking"
                    },
                  + {
                      + Action    = [
                          + "elasticloadbalancing:CreateTargetGroup",
                          + "elasticloadbalancing:CreateRule",
                          + "elasticloadbalancing:CreateLoadBalancer",
                          + "elasticloadbalancing:CreateListener",
                          + "ec2:CreateSecurityGroup",
                        ]
                      + Condition = {
                          + StringEquals = {
                              + "aws:RequestTag/eks:eks-cluster-name" = "${aws:PrincipalTag/eks:eks-cluster-name}"
                            }
                        }
                      + Effect    = "Allow"
                      + Resource  = "*"
                      + Sid       = "LoadBalancer"
                    },
                  + {
                      + Action    = "shield:CreateProtection"
                      + Condition = {
                          + StringEquals = {
                              + "aws:RequestTag/eks:eks-cluster-name" = "${aws:PrincipalTag/eks:eks-cluster-name}"
                            }
                        }
                      + Effect    = "Allow"
                      + Resource  = "*"
                      + Sid       = "ShieldProtection"
                    },
                  + {
                      + Action    = "shield:TagResource"
                      + Condition = {
                          + StringEquals = {
                              + "aws:RequestTag/eks:eks-cluster-name" = "${aws:PrincipalTag/eks:eks-cluster-name}"
                            }
                        }
                      + Effect    = "Allow"
                      + Resource  = "arn:aws:shield::*:protection/*"
                      + Sid       = "ShieldTagResource"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + policy_id        = (known after apply)
      + tags             = {
          + "Environment" = "example"
        }
      + tags_all         = {
          + "Environment" = "example"
        }
    }
  # module.eks.aws_iam_role.this[0] will be created
  + resource "aws_iam_role" "this" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = [
                          + "sts:TagSession",
                          + "sts:AssumeRole",
                        ]
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "eks.amazonaws.com"
                        }
                      + Sid       = "EKSClusterAssumeRole"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = true
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = (known after apply)
      + name_prefix           = "example-cluster-"
      + path                  = "/"
      + tags                  = {
          + "Environment" = "example"
        }
      + tags_all              = {
          + "Environment" = "example"
        }
      + unique_id             = (known after apply)
      + inline_policy (known after apply)
    }
  # module.eks.aws_iam_role_policy_attachment.cluster_encryption[0] will be created
  + resource "aws_iam_role_policy_attachment" "cluster_encryption" {
      + id         = (known after apply)
      + policy_arn = (known after apply)
      + role       = (known after apply)
    }
  # module.eks.aws_iam_role_policy_attachment.custom[0] will be created
  + resource "aws_iam_role_policy_attachment" "custom" {
      + id         = (known after apply)
      + policy_arn = (known after apply)
      + role       = (known after apply)
    }
  # module.eks.aws_iam_role_policy_attachment.this["AmazonEKSClusterPolicy"] will be created
  + resource "aws_iam_role_policy_attachment" "this" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
      + role       = (known after apply)
    }
  # module.eks.aws_iam_role_policy_attachment.this["AmazonEKSVPCResourceController"] will be created
  + resource "aws_iam_role_policy_attachment" "this" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSVPCResourceController"
      + role       = (known after apply)
    }
  # module.eks.aws_security_group.cluster[0] will be created
  + resource "aws_security_group" "cluster" {
      + arn                    = (known after apply)
      + description            = "EKS cluster security group"
      + egress                 = (known after apply)
      + id                     = (known after apply)
      + ingress                = (known after apply)
      + name                   = (known after apply)
      + name_prefix            = "example-cluster-"
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Environment" = "example"
          + "Name"        = "example-cluster"
        }
      + tags_all               = {
          + "Environment" = "example"
          + "Name"        = "example-cluster"
        }
      + vpc_id                 = (known after apply)
    }
  # module.eks.aws_security_group.node[0] will be created
  + resource "aws_security_group" "node" {
      + arn                    = (known after apply)
      + description            = "EKS node shared security group"
      + egress                 = (known after apply)
      + id                     = (known after apply)
      + ingress                = (known after apply)
      + name                   = (known after apply)
      + name_prefix            = "example-node-"
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Environment"                   = "example"
          + "Name"                          = "example-node"
          + "kubernetes.io/cluster/example" = "owned"
        }
      + tags_all               = {
          + "Environment"                   = "example"
          + "Name"                          = "example-node"
          + "kubernetes.io/cluster/example" = "owned"
        }
      + vpc_id                 = (known after apply)
    }
  # module.eks.aws_security_group_rule.cluster["ingress_nodes_443"] will be created
  + resource "aws_security_group_rule" "cluster" {
      + description              = "Node groups to cluster API"
      + from_port                = 443
      + id                       = (known after apply)
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 443
      + type                     = "ingress"
    }
  # module.eks.aws_security_group_rule.node["egress_all"] will be created
  + resource "aws_security_group_rule" "node" {
      + cidr_blocks              = [
          + "0.0.0.0/0",
        ]
      + description              = "Allow all egress"
      + from_port                = 0
      + id                       = (known after apply)
      + prefix_list_ids          = []
      + protocol                 = "-1"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 0
      + type                     = "egress"
    }
  # module.eks.aws_security_group_rule.node["ingress_cluster_443"] will be created
  + resource "aws_security_group_rule" "node" {
      + description              = "Cluster API to node groups"
      + from_port                = 443
      + id                       = (known after apply)
      + prefix_list_ids          = []
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 443
      + type                     = "ingress"
    }
  # module.eks.aws_security_group_rule.node["ingress_cluster_4443_webhook"] will be created
  + resource "aws_security_group_rule" "node" {
      + description              = "Cluster API to node 4443/tcp webhook"
      + from_port                = 4443
      + id                       = (known after apply)
      + prefix_list_ids          = []
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 4443
      + type                     = "ingress"
    }
  # module.eks.aws_security_group_rule.node["ingress_cluster_6443_webhook"] will be created
  + resource "aws_security_group_rule" "node" {
      + description              = "Cluster API to node 6443/tcp webhook"
      + from_port                = 6443
      + id                       = (known after apply)
      + prefix_list_ids          = []
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 6443
      + type                     = "ingress"
    }
  # module.eks.aws_security_group_rule.node["ingress_cluster_8443_webhook"] will be created
  + resource "aws_security_group_rule" "node" {
      + description              = "Cluster API to node 8443/tcp webhook"
      + from_port                = 8443
      + id                       = (known after apply)
      + prefix_list_ids          = []
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 8443
      + type                     = "ingress"
    }
  # module.eks.aws_security_group_rule.node["ingress_cluster_9443_webhook"] will be created
  + resource "aws_security_group_rule" "node" {
      + description              = "Cluster API to node 9443/tcp webhook"
      + from_port                = 9443
      + id                       = (known after apply)
      + prefix_list_ids          = []
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 9443
      + type                     = "ingress"
    }
  # module.eks.aws_security_group_rule.node["ingress_cluster_kubelet"] will be created
  + resource "aws_security_group_rule" "node" {
      + description              = "Cluster API to node kubelets"
      + from_port                = 10250
      + id                       = (known after apply)
      + prefix_list_ids          = []
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 10250
      + type                     = "ingress"
    }
  # module.eks.aws_security_group_rule.node["ingress_nodes_ephemeral"] will be created
  + resource "aws_security_group_rule" "node" {
      + description              = "Node to node ingress on ephemeral ports"
      + from_port                = 1025
      + id                       = (known after apply)
      + prefix_list_ids          = []
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = true
      + source_security_group_id = (known after apply)
      + to_port                  = 65535
      + type                     = "ingress"
    }
  # module.eks.aws_security_group_rule.node["ingress_self_coredns_tcp"] will be created
  + resource "aws_security_group_rule" "node" {
      + description              = "Node to node CoreDNS"
      + from_port                = 53
      + id                       = (known after apply)
      + prefix_list_ids          = []
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = true
      + source_security_group_id = (known after apply)
      + to_port                  = 53
      + type                     = "ingress"
    }
  # module.eks.aws_security_group_rule.node["ingress_self_coredns_udp"] will be created
  + resource "aws_security_group_rule" "node" {
      + description              = "Node to node CoreDNS UDP"
      + from_port                = 53
      + id                       = (known after apply)
      + prefix_list_ids          = []
      + protocol                 = "udp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = true
      + source_security_group_id = (known after apply)
      + to_port                  = 53
      + type                     = "ingress"
    }
  # module.eks.time_sleep.this[0] will be created
  + resource "time_sleep" "this" {
      + create_duration = "30s"
      + id              = (known after apply)
      + triggers        = {
          + "cluster_certificate_authority_data" = (known after apply)
          + "cluster_endpoint"                   = (known after apply)
          + "cluster_name"                       = (known after apply)
          + "cluster_service_cidr"               = (known after apply)
          + "cluster_version"                    = "1.30"
        }
    }
  # module.eks.module.eks_managed_node_group["worker-group-1"].aws_eks_node_group.this[0] will be created
  + resource "aws_eks_node_group" "this" {
      + ami_type               = "AL2023_x86_64_STANDARD"
      + arn                    = (known after apply)
      + capacity_type          = (known after apply)
      + cluster_name           = (known after apply)
      + disk_size              = (known after apply)
      + id                     = (known after apply)
      + instance_types         = [
          + "t2.small",
        ]
      + node_group_name        = (known after apply)
      + node_group_name_prefix = "worker-group-1-"
      + node_role_arn          = (known after apply)
      + release_version        = (known after apply)
      + resources              = (known after apply)
      + status                 = (known after apply)
      + subnet_ids             = (known after apply)
      + tags                   = {
          + "Environment" = "example"
          + "Name"        = "worker-group-1"
        }
      + tags_all               = {
          + "Environment" = "example"
          + "Name"        = "worker-group-1"
        }
      + version                = "1.30"
      + launch_template {
          + id      = (known after apply)
          + name    = (known after apply)
          + version = (known after apply)
        }
      + node_repair_config (known after apply)
      + scaling_config {
          + desired_size = 2
          + max_size     = 2
          + min_size     = 2
        }
      + timeouts {}
      + update_config {
          + max_unavailable_percentage = 33
        }
    }
  # module.eks.module.eks_managed_node_group["worker-group-1"].aws_iam_role.this[0] will be created
  + resource "aws_iam_role" "this" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "ec2.amazonaws.com"
                        }
                      + Sid       = "EKSNodeAssumeRole"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + description           = "EKS managed node group IAM role"
      + force_detach_policies = true
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = (known after apply)
      + name_prefix           = "worker-group-1-eks-node-group-"
      + path                  = "/"
      + tags                  = {
          + "Environment" = "example"
        }
      + tags_all              = {
          + "Environment" = "example"
        }
      + unique_id             = (known after apply)
      + inline_policy (known after apply)
    }
  # module.eks.module.eks_managed_node_group["worker-group-1"].aws_iam_role_policy_attachment.this["AmazonEC2ContainerRegistryReadOnly"] will be created
  + resource "aws_iam_role_policy_attachment" "this" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
      + role       = (known after apply)
    }
  # module.eks.module.eks_managed_node_group["worker-group-1"].aws_iam_role_policy_attachment.this["AmazonEKSWorkerNodePolicy"] will be created
  + resource "aws_iam_role_policy_attachment" "this" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
      + role       = (known after apply)
    }
  # module.eks.module.eks_managed_node_group["worker-group-1"].aws_iam_role_policy_attachment.this["AmazonEKS_CNI_Policy"] will be created
  + resource "aws_iam_role_policy_attachment" "this" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
      + role       = (known after apply)
    }
  # module.eks.module.eks_managed_node_group["worker-group-1"].aws_launch_template.this[0] will be created
  + resource "aws_launch_template" "this" {
      + arn                    = (known after apply)
      + default_version        = (known after apply)
      + description            = "Custom launch template for worker-group-1 EKS managed node group"
      + id                     = (known after apply)
      + latest_version         = (known after apply)
      + name                   = (known after apply)
      + name_prefix            = "worker-group-1-"
      + tags                   = {
          + "Environment" = "example"
        }
      + tags_all               = {
          + "Environment" = "example"
        }
      + update_default_version = true
      + vpc_security_group_ids = (known after apply)
      + metadata_options {
          + http_endpoint               = "enabled"
          + http_protocol_ipv6          = (known after apply)
          + http_put_response_hop_limit = 2
          + http_tokens                 = "required"
          + instance_metadata_tags      = (known after apply)
        }
      + monitoring {
          + enabled = true
        }
      + tag_specifications {
          + resource_type = "instance"
          + tags          = {
              + "Environment" = "example"
              + "Name"        = "worker-group-1"
            }
        }
      + tag_specifications {
          + resource_type = "network-interface"
          + tags          = {
              + "Environment" = "example"
              + "Name"        = "worker-group-1"
            }
        }
      + tag_specifications {
          + resource_type = "volume"
          + tags          = {
              + "Environment" = "example"
              + "Name"        = "worker-group-1"
            }
        }
    }
  # module.eks.module.eks_managed_node_group["worker-group-2"].aws_eks_node_group.this[0] will be created
  + resource "aws_eks_node_group" "this" {
      + ami_type               = "AL2023_x86_64_STANDARD"
      + arn                    = (known after apply)
      + capacity_type          = (known after apply)
      + cluster_name           = (known after apply)
      + disk_size              = (known after apply)
      + id                     = (known after apply)
      + instance_types         = [
          + "t2.medium",
        ]
      + node_group_name        = (known after apply)
      + node_group_name_prefix = "worker-group-2-"
      + node_role_arn          = (known after apply)
      + release_version        = (known after apply)
      + resources              = (known after apply)
      + status                 = (known after apply)
      + subnet_ids             = (known after apply)
      + tags                   = {
          + "Environment" = "example"
          + "Name"        = "worker-group-2"
        }
      + tags_all               = {
          + "Environment" = "example"
          + "Name"        = "worker-group-2"
        }
      + version                = "1.30"
      + launch_template {
          + id      = (known after apply)
          + name    = (known after apply)
          + version = (known after apply)
        }
      + node_repair_config (known after apply)
      + scaling_config {
          + desired_size = 1
          + max_size     = 1
          + min_size     = 1
        }
      + timeouts {}
      + update_config {
          + max_unavailable_percentage = 33
        }
    }
  # module.eks.module.eks_managed_node_group["worker-group-2"].aws_iam_role.this[0] will be created
  + resource "aws_iam_role" "this" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "ec2.amazonaws.com"
                        }
                      + Sid       = "EKSNodeAssumeRole"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + description           = "EKS managed node group IAM role"
      + force_detach_policies = true
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = (known after apply)
      + name_prefix           = "worker-group-2-eks-node-group-"
      + path                  = "/"
      + tags                  = {
          + "Environment" = "example"
        }
      + tags_all              = {
          + "Environment" = "example"
        }
      + unique_id             = (known after apply)
      + inline_policy (known after apply)
    }
  # module.eks.module.eks_managed_node_group["worker-group-2"].aws_iam_role_policy_attachment.this["AmazonEC2ContainerRegistryReadOnly"] will be created
  + resource "aws_iam_role_policy_attachment" "this" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
      + role       = (known after apply)
    }
  # module.eks.module.eks_managed_node_group["worker-group-2"].aws_iam_role_policy_attachment.this["AmazonEKSWorkerNodePolicy"] will be created
  + resource "aws_iam_role_policy_attachment" "this" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
      + role       = (known after apply)
    }
  # module.eks.module.eks_managed_node_group["worker-group-2"].aws_iam_role_policy_attachment.this["AmazonEKS_CNI_Policy"] will be created
  + resource "aws_iam_role_policy_attachment" "this" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
      + role       = (known after apply)
    }
  # module.eks.module.eks_managed_node_group["worker-group-2"].aws_launch_template.this[0] will be created
  + resource "aws_launch_template" "this" {
      + arn                    = (known after apply)
      + default_version        = (known after apply)
      + description            = "Custom launch template for worker-group-2 EKS managed node group"
      + id                     = (known after apply)
      + latest_version         = (known after apply)
      + name                   = (known after apply)
      + name_prefix            = "worker-group-2-"
      + tags                   = {
          + "Environment" = "example"
        }
      + tags_all               = {
          + "Environment" = "example"
        }
      + update_default_version = true
      + vpc_security_group_ids = (known after apply)
      + metadata_options {
          + http_endpoint               = "enabled"
          + http_protocol_ipv6          = (known after apply)
          + http_put_response_hop_limit = 2
          + http_tokens                 = "required"
          + instance_metadata_tags      = (known after apply)
        }
      + monitoring {
          + enabled = true
        }
      + tag_specifications {
          + resource_type = "instance"
          + tags          = {
              + "Environment" = "example"
              + "Name"        = "worker-group-2"
            }
        }
      + tag_specifications {
          + resource_type = "network-interface"
          + tags          = {
              + "Environment" = "example"
              + "Name"        = "worker-group-2"
            }
        }
      + tag_specifications {
          + resource_type = "volume"
          + tags          = {
              + "Environment" = "example"
              + "Name"        = "worker-group-2"
            }
        }
    }
  # module.eks.module.kms.data.aws_iam_policy_document.this[0] will be read during apply
  # (config refers to values not yet known)
 <= data "aws_iam_policy_document" "this" {
      + id                        = (known after apply)
      + json                      = (known after apply)
      + minified_json             = (known after apply)
      + override_policy_documents = []
      + source_policy_documents   = []
      + statement {
          + actions   = [
              + "kms:*",
            ]
          + resources = [
              + "*",
            ]
          + sid       = "Default"
          + principals {
              + identifiers = [
                  + "arn:aws:iam::123456789012:root",
                ]
              + type        = "AWS"
            }
        }
      + statement {
          + actions   = [
              + "kms:CancelKeyDeletion",
              + "kms:Create*",
              + "kms:Delete*",
              + "kms:Describe*",
              + "kms:Disable*",
              + "kms:Enable*",
              + "kms:Get*",
              + "kms:ImportKeyMaterial",
              + "kms:List*",
              + "kms:Put*",
              + "kms:ReplicateKey",
              + "kms:Revoke*",
              + "kms:ScheduleKeyDeletion",
              + "kms:TagResource",
              + "kms:UntagResource",
              + "kms:Update*",
            ]
          + resources = [
              + "*",
            ]
          + sid       = "KeyAdministration"
          + principals {
              + identifiers = [
                  + "arn:aws:iam::123456789012:user/terraform",
                ]
              + type        = "AWS"
            }
        }
      + statement {
          + actions   = [
              + "kms:Decrypt",
              + "kms:DescribeKey",
              + "kms:Encrypt",
              + "kms:GenerateDataKey*",
              + "kms:ReEncrypt*",
            ]
          + resources = [
              + "*",
            ]
          + sid       = "KeyUsage"
          + principals {
              + identifiers = [
                  + (known after apply),
                ]
              + type        = "AWS"
            }
        }
    }
  # module.eks.module.kms.aws_kms_alias.this["cluster"] will be created
  + resource "aws_kms_alias" "this" {
      + arn            = (known after apply)
      + id             = (known after apply)
      + name           = "alias/eks/example"
      + name_prefix    = (known after apply)
      + target_key_arn = (known after apply)
      + target_key_id  = (known after apply)
    }
  # module.eks.module.kms.aws_kms_key.this[0] will be created
  + resource "aws_kms_key" "this" {
      + arn                                = (known after apply)
      + bypass_policy_lockout_safety_check = false
      + customer_master_key_spec           = "SYMMETRIC_DEFAULT"
      + description                        = "example cluster encryption key"
      + enable_key_rotation                = true
      + id                                 = (known after apply)
      + is_enabled                         = true
      + key_id                             = (known after apply)
      + key_usage                          = "ENCRYPT_DECRYPT"
      + multi_region                       = false
      + policy                             = (known after apply)
      + rotation_period_in_days            = (known after apply)
      + tags                               = {
          + "Environment"           = "example"
          + "terraform-aws-modules" = "eks"
        }
      + tags_all                           = {
          + "Environment"           = "example"
          + "terraform-aws-modules" = "eks"
        }
    }
  # module.eks.module.eks_managed_node_group["worker-group-1"].module.user_data.null_resource.validate_cluster_service_cidr will be created
  + resource "null_resource" "validate_cluster_service_cidr" {
      + id = (known after apply)
    }
  # module.eks.module.eks_managed_node_group["worker-group-2"].module.user_data.null_resource.validate_cluster_service_cidr will be created
  + resource "null_resource" "validate_cluster_service_cidr" {
      + id = (known after apply)
    }
Plan: 85 to add, 0 to change, 0 to destroy.
Changes to Outputs:
  + cluster_endpoint          = (known after apply)
  + cluster_name              = "example"
  + cluster_security_group_id = (known after apply)
  + prvt_subnet_arn           = [
      + (known after apply),
      + (known after apply),
      + (known after apply),
    ]
  + prvt_subnet_cidr          = [
      + "10.100.2.0/25",
      + "10.100.2.128/25",
      + "10.100.3.0/25",
    ]
  + prvt_subnet_id            = [
      + (known after apply),
      + (known after apply),
      + (known after apply),
    ]
  + public_subnet_arn         = [
      + (known after apply),
      + (known after apply),
      + (known after apply),
    ]
  + public_subnet_cidr        = [
      + "10.100.0.0/25",
      + "10.100.0.128/25",
      + "10.100.1.0/25",
    ]
  + public_subnet_id          = [
      + (known after apply),
      + (known after apply),
      + (known after apply),
    ]
  + vpc_cidr_block            = "10.100.0.0/22"
  + vpc_id                    = (known after apply)
  + vpc_main_rt_id            = (known after apply)

 
